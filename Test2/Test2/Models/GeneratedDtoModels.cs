//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

using System.Collections.Generic;
using System.Collections.ObjectModel;

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"

namespace Test2.Client.Models
{
    using System = global::System;

    

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error 
    {
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchEncryptResponse : System.Collections.ObjectModel.Collection<Anonymous3>
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchDecryptResponse : System.Collections.ObjectModel.Collection<Anonymous4>
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchSignResponse : System.Collections.ObjectModel.Collection<Anonymous5>
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchVerifyResponse : System.Collections.ObjectModel.Collection<Anonymous6>
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchMacResponse : System.Collections.ObjectModel.Collection<Anonymous7>
    {
    
    }
    
    /// <summary>This uniquely identifies a persisted or transient sobject. Exactly one of `kid`, `name`, and `transient_key` must be present.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SobjectDescriptor 
    {
        /// <summary>Key ID uniquely identifying this persisted security object.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>Name of this persisted security object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Transient key blob.</summary>
        [Newtonsoft.Json.JsonProperty("transient_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transient_key { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class App 
    {
        /// <summary>Name of the application. Application names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Application ID uniquely identifying this application.</summary>
        [Newtonsoft.Json.JsonProperty("app_id", Required = Newtonsoft.Json.Required.Always)]
        public string App_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("auth_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AppAuthType Auth_type { get; set; }
    
        /// <summary>Description of this application.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Interface used with this application (PKCS11, CNG, JCE, KMIP, etc.).</summary>
        [Newtonsoft.Json.JsonProperty("interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface { get; set; }
    
        /// <summary>The account ID of the account that this application belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Always)]
        public string Acct_id { get; set; }
    
        /// <summary>An array of Security Group IDs. The application belongs to each Security Group in this array.</summary>
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Groups { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>The default group of this application. This is the group where security objects will be created by default by this application.</summary>
        [Newtonsoft.Json.JsonProperty("default_group", Required = Newtonsoft.Json.Required.Always)]
        public string Default_group { get; set; }
    
        /// <summary>Whether this application is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
        /// <summary>The user-defined type of this application.</summary>
        [Newtonsoft.Json.JsonProperty("app_type", Required = Newtonsoft.Json.Required.Always)]
        public string App_type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("creator", Required = Newtonsoft.Json.Required.Always)]
        public CreatorType Creator { get; set; } = new CreatorType();
    
        /// <summary>When this application was created.</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        public string Created_at { get; set; }
    
        /// <summary>When this application was last used.</summary>
        [Newtonsoft.Json.JsonProperty("lastused_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lastused_at { get; set; }
    
        [Newtonsoft.Json.JsonProperty("oauth_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AppOauthConfig Oauth_config { get; set; }
    
        /// <summary>Certificate expiration date.</summary>
        [Newtonsoft.Json.JsonProperty("cert_not_after", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cert_not_after { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AppRequest 
    {
        /// <summary>Name of this application. Application names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Description of this application.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Map from UUIDs to group permissions</summary>
        [Newtonsoft.Json.JsonProperty("add_groups", Required = Newtonsoft.Json.Required.Always)]
        public Dictionary<string, Collection<AppPermissions>> Add_groups { get; set; } = new System.Collections.Generic.Dictionary<string, System.Collections.ObjectModel.Collection<AppPermissions>>();
    
        /// <summary>Array of UUID of group</summary>
        [Newtonsoft.Json.JsonProperty("del_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Del_groups { get; set; }
    
        /// <summary>Map from UUIDs to group permissions</summary>
        [Newtonsoft.Json.JsonProperty("mod_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<AppPermissions>> Mod_groups { get; set; }
    
        /// <summary>The default group of this application. This is the group where security objects will be created by default by this application.</summary>
        [Newtonsoft.Json.JsonProperty("default_group", Required = Newtonsoft.Json.Required.Always)]
        public string Default_group { get; set; }
    
        /// <summary>Whether this application is enabled</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AppOauthConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AppOauthConfig AppOauthConfig { get; set; }
    
        /// <summary>Interface used with this application (PKCS11, CNG, JCE, KMIP, etc.).</summary>
        [Newtonsoft.Json.JsonProperty("interface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interface { get; set; }
    
        /// <summary>The user-defined type of this application.</summary>
        [Newtonsoft.Json.JsonProperty("app_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string App_type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("credential", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AppCredential Credential { get; set; }
    
        /// <summary>Size in bytes of app's secret.</summary>
        [Newtonsoft.Json.JsonProperty("secret_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Secret_size { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AppResetSecretRequest 
    {
        /// <summary>Size in bytes of app's secret.</summary>
        [Newtonsoft.Json.JsonProperty("secret_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Secret_size { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AppCredentialResponse 
    {
        /// <summary>Uuid format string, example - a41152ed-c26e-4c6e-a8d1-8820e36972c3</summary>
        [Newtonsoft.Json.JsonProperty("app_id", Required = Newtonsoft.Json.Required.Always)]
        public string App_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("credential", Required = Newtonsoft.Json.Required.Always)]
        public AppCredential Credential { get; set; } = new AppCredential();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Group 
    {
        /// <summary>Name of the group. Group names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Group ID uniquely identifying this group.</summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        /// <summary>Description of the group.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Account ID of the account this Group belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Acct_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("creator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreatorType Creator { get; set; }
    
        /// <summary>When this group was created.</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>Map from UUIDs to HmgConfig objects</summary>
        [Newtonsoft.Json.JsonProperty("hmg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HmgConfig> Hmg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_undo_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyUndoPolicy Key_undo_policy { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GroupRequest 
    {
        /// <summary>Name of the group. Group names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Description of the group.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Account ID of the account the new group will belong to.</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Acct_id { get; set; }
    
        /// <summary>List of HmgConfig objects to add</summary>
        [Newtonsoft.Json.JsonProperty("add_hmg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HmgConfig> Add_hmg { get; set; }
    
        /// <summary>Map from UUIDs to HmgConfig objects to update</summary>
        [Newtonsoft.Json.JsonProperty("mod_hmg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HmgConfig> Mod_hmg { get; set; }
    
        /// <summary>List of HmgConfig UUIDs to delete</summary>
        [Newtonsoft.Json.JsonProperty("del_hmg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Del_hmg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_undo_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyUndoPolicy Key_undo_policy { get; set; }
    
    
    }
    
    /// <summary>Type of security object.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ObjectType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AES")]
        AES = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DES")]
        DES = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DES3")]
        DES3 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RSA")]
        RSA = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DSA")]
        DSA = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EC")]
        EC = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OPAQUE")]
        OPAQUE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HMAC")]
        HMAC = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SECRET")]
        SECRET = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CERTIFICATE")]
        CERTIFICATE = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ROUND5BETA")]
        ROUND5BETA = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LEDABETA")]
        LEDABETA = 11,
    
    }
    
    /// <summary>Desired key formatting</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum KeyFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Default")]
        Default = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Pkcs8")]
        Pkcs8 = 1,
    
    }
    
    /// <summary>Type of cipher mode, required for symmetric key algorithms.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CipherMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ECB")]
        ECB = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CBC")]
        CBC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CBCNOPAD")]
        CBCNOPAD = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CFB")]
        CFB = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OFB")]
        OFB = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CTR")]
        CTR = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GCM")]
        GCM = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCM")]
        CCM = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"KW")]
        KW = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"KWP")]
        KWP = 9,
    
    }
    
    /// <summary>Specifies the Mask Generating Function (MGF) to use.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Mgf 
    {
        /// <summary>Parameters for MGF1.</summary>
        [Newtonsoft.Json.JsonProperty("mgf1", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Mgf1 Mgf1 { get; set; }
    
    
    }
    
    /// <summary>Type of padding to use for RSA encryption. The use of PKCS#1 v1.5 padding is strongly discouraged, because of its susceptibility to Bleichenbacher's attack. The padding specified must adhere to the key's encryption policy, see `RsaEncryptionPolicy`. If not specified, the default based on the key's policy will be used.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RsaEncryptionPadding 
    {
        /// <summary>PKCS#1 v1.5 padding</summary>
        [Newtonsoft.Json.JsonProperty("PKCS1_V15", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object PKCS1_V15 { get; set; }
    
        /// <summary>Optimal Asymmetric Encryption Padding (PKCS#1 v2.1)</summary>
        [Newtonsoft.Json.JsonProperty("OAEP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OAEP OAEP { get; set; }
    
    
    }
    
    /// <summary>Type of padding to use for RSA signatures. The padding specified must adhere to the key's signature policy, see `RsaSignaturePolicy`. If not specified, the default based on the key's policy will be used.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RsaSignaturePadding 
    {
        /// <summary>PKCS#1 v1.5 padding</summary>
        [Newtonsoft.Json.JsonProperty("PKCS1_V15", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object PKCS1_V15 { get; set; }
    
        /// <summary>Probabilistic Signature Scheme (PKCS#1 v2.1)</summary>
        [Newtonsoft.Json.JsonProperty("PSS", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PSS PSS { get; set; }
    
    
    }
    
    /// <summary>Type of padding to use for RSA signatures. The padding specified must adhere to the key's signature policy, see `RsaSignaturePolicy`. If not specified, the default based on the key's policy will be used.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignatureMode 
    {
        /// <summary>PKCS#1 v1.5 padding</summary>
        [Newtonsoft.Json.JsonProperty("PKCS1_V15", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object PKCS1_V15 { get; set; }
    
        /// <summary>Probabilistic Signature Scheme (PKCS#1 v2.1)</summary>
        [Newtonsoft.Json.JsonProperty("PSS", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PSS2 PSS { get; set; }
    
    
    }
    
    /// <summary>`CipherMode` or `RsaEncryptionPadding`, depending on the encryption algorithm</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CryptMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ECB")]
        ECB = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CBC")]
        CBC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CBCNOPAD")]
        CBCNOPAD = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CFB")]
        CFB = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CTR")]
        CTR = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OFB")]
        OFB = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GCM")]
        GCM = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CCM")]
        CCM = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PKCS1_V15")]
        PKCS1_V15 = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OAEP_MGF1_SHA1")]
        OAEP_MGF1_SHA1 = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OAEP_MGF1_SHA256")]
        OAEP_MGF1_SHA256 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OAEP_MGF1_SHA384")]
        OAEP_MGF1_SHA384 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OAEP_MGF1_SHA512")]
        OAEP_MGF1_SHA512 = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FPE")]
        FPE = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"KW")]
        KW = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"KWP")]
        KWP = 15,
    
    }
    
    /// <summary>Credential for an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AppCredential 
    {
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secret { get; set; }
    
        [Newtonsoft.Json.JsonProperty("certificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Certificate { get; set; }
    
        [Newtonsoft.Json.JsonProperty("trustedca", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Trustedca Trustedca { get; set; }
    
        [Newtonsoft.Json.JsonProperty("googleserviceaccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Googleserviceaccount { get; set; }
    
        /// <summary>Configuration for signed JWT authentication.</summary>
        [Newtonsoft.Json.JsonProperty("signedjwt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Signedjwt Signedjwt { get; set; }
    
    
    }
    
    /// <summary>Oauth configuration for this application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AppOauthConfig 
    {
        [Newtonsoft.Json.JsonProperty("redirect_uris", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Redirect_uris { get; set; }
    
        /// <summary>Whether oauth for this app is disabled</summary>
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; }
    
    
    }
    
    /// <summary>Authentication type for an application.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AppAuthType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Secret")]
        Secret = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Certificate")]
        Certificate = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TrustedCa")]
        TrustedCa = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GoogleServiceAccount")]
        GoogleServiceAccount = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SignedJwt")]
        SignedJwt = 4,
    
    }
    
    /// <summary>What type of entity created another entity.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CreatorType 
    {
        /// <summary>The application ID of the application that created this entity, if this entity was created by an application.</summary>
        [Newtonsoft.Json.JsonProperty("app", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string App { get; set; }
    
        /// <summary>The user ID of the user who created this entity, if this entity was created by a user.</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }
    
    
    }
    
    /// <summary>Where this security object originated.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ObjectOrigin
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FortanixHSM")]
        FortanixHSM = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"External")]
        External = 1,
    
    }
    
    /// <summary>Message digest algorithm.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DigestAlgorithm
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Blake2b256")]
        Blake2b256 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Blake2b384")]
        Blake2b384 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Blake2b512")]
        Blake2b512 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Blake2s256")]
        Blake2s256 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RIPEMD160")]
        RIPEMD160 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA1")]
        SHA1 = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA256")]
        SHA256 = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA384")]
        SHA384 = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA512")]
        SHA512 = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA3_224")]
        SHA3_224 = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA3_256")]
        SHA3_256 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA3_384")]
        SHA3_384 = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SHA3_512")]
        SHA3_512 = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Ssl3")]
        Ssl3 = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Streebog256")]
        Streebog256 = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Streebog512")]
        Streebog512 = 15,
    
    }
    
    /// <summary>Permissions allowed to be performed by an app.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AppPermissions
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ENCRYPT")]
        ENCRYPT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DECRYPT")]
        DECRYPT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MASKDECRYPT")]
        MASKDECRYPT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WRAPKEY")]
        WRAPKEY = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNWRAPKEY")]
        UNWRAPKEY = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DERIVEKEY")]
        DERIVEKEY = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MACGENERATE")]
        MACGENERATE = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MACVERIFY")]
        MACVERIFY = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MANAGE")]
        MANAGE = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SIGN")]
        SIGN = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VERIFY")]
        VERIFY = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AGREEKEY")]
        AGREEKEY = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPORT")]
        EXPORT = 12,
    
    }
    
    /// <summary>Operations allowed to be performed by a given key.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum KeyOperations
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SIGN")]
        SIGN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VERIFY")]
        VERIFY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ENCRYPT")]
        ENCRYPT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DECRYPT")]
        DECRYPT = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WRAPKEY")]
        WRAPKEY = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNWRAPKEY")]
        UNWRAPKEY = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DERIVEKEY")]
        DERIVEKEY = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AGREEKEY")]
        AGREEKEY = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MACGENERATE")]
        MACGENERATE = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MACVERIFY")]
        MACVERIFY = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPORT")]
        EXPORT = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPMANAGEABLE")]
        APPMANAGEABLE = 11,
    
    }
    
    /// <summary>Identifies a standardized elliptic curve. Required for operations involving EC keys.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum EllipticCurve
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SecP192K1")]
        SecP192K1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SecP224K1")]
        SecP224K1 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SecP256K1")]
        SecP256K1 = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NistP192")]
        NistP192 = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NistP224")]
        NistP224 = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NistP256")]
        NistP256 = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NistP384")]
        NistP384 = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NistP521")]
        NistP521 = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Gost256A")]
        Gost256A = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Ed25519")]
        Ed25519 = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"X25519")]
        X25519 = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"X448")]
        X448 = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RevertRequest 
    {
        /// <summary>The IDs of the HistoryItems that should be reverted. In order to revert to a HistoryItem, that id of that HistoryItem and all more recent HistoryItems need to be provided.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ids", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Ids { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Reasons to revoke a security object.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RevocationReasonCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Unspecified")]
        Unspecified = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"KeyCompromise")]
        KeyCompromise = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CACompromise")]
        CACompromise = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AffiliationChanged")]
        AffiliationChanged = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Superseded")]
        Superseded = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CessationOfOperation")]
        CessationOfOperation = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PrivilegeWithdrawn")]
        PrivilegeWithdrawn = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RevocationReason 
    {
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RevocationReasonCode Code { get; set; }
    
        /// <summary>Field that is used exclusively for audit trail/logging purposes and MAY contain additional information about why the object was revoked.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        /// <summary>An optional field specifying when this security object was compromised.</summary>
        [Newtonsoft.Json.JsonProperty("compromise_occurance_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Compromise_occurance_date { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SobjectRequest 
    {
        /// <summary>Name of the security object to create or import. Security object names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Description of the security object to create or import.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Size in bits (not bytes) of the security object to create or import. Required for symmetric keys. For DSA keys, it represents the size of `p`; allowed values are 2048 or 3072. Deprecated for RSA keys, specify it in `RsaOptions` instead.</summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Key_size { get; set; }
    
        /// <summary>For RSA keys only. Deprecated. Specify in `RsaOptions` instead. Public exponent to use when generating an RSA key.</summary>
        [Newtonsoft.Json.JsonProperty("pub_exponent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Pub_exponent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("elliptic_curve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EllipticCurve? Elliptic_curve { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rsa", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RsaOptions Rsa { get; set; }
    
        [Newtonsoft.Json.JsonProperty("dsa", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DsaOptions Dsa { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fpe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeOptions Fpe { get; set; }
    
        /// <summary>Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("obj_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Obj_type { get; set; }
    
        /// <summary>Optional array of key operations to be enabled for this security object. If this property is not provided, the SDKMS server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>User-defined metadata for this key. Stored as key-value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        /// <summary>When importing a security object, this field contains the binary contents to import. When creating a security object, this field is unused. The value of an OPAQUE or CERTIFICATE object is always returned. For other objects, the value is returned only with `/crypto/v1/keys/export` API (if the object is exportable).
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Value { get; set; }
    
        /// <summary>Whether the new security object should be enabled. Disabled security objects may not perform cryptographic operations.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        /// <summary>If this is true, SDKMS will create a transient key.</summary>
        [Newtonsoft.Json.JsonProperty("transient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Transient { get; set; }
    
        [Newtonsoft.Json.JsonProperty("deterministic_signatures", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deterministic_signatures { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyObjectState? State { get; set; }
    
        /// <summary>When this object will be deactivated.</summary>
        [Newtonsoft.Json.JsonProperty("deactivation_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Deactivation_date { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PersistTransientKeyRequest 
    {
        /// <summary>Name of the persisted security object. Security object names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Description of the persisted security object.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>User-defined metadata for the persisted key. Stored as key-value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        /// <summary>Whether the new security object should be enabled. Disabled security objects may not perform cryptographic operations.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        /// <summary>Optional array of key operations to be enabled for this security object. If this property is not provided, the SDKMS server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>Group ID (not name) of the security group that the persisted security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        /// <summary>Transient key blob.</summary>
        [Newtonsoft.Json.JsonProperty("transient_key", Required = Newtonsoft.Json.Required.Always)]
        public string Transient_key { get; set; }
    
    
    }
    
    /// <summary>Encodes the mechanism to be used when deriving a new key from an existing key. Exactly one mechanism should be supplied. Currently, the only supported mechanism is encrypting data to derive the new key. Other mechanisms may be added in the future.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DeriveKeyMechanism 
    {
        [Newtonsoft.Json.JsonProperty("encrypt_data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptRequest Encrypt_data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DeriveKeyRequest 
    {
        /// <summary>Name of the derived key. Key names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        /// <summary>Key size of the derived key in bits (not bytes).</summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Always)]
        public int Key_size { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Key_type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mechanism", Required = Newtonsoft.Json.Required.Always)]
        public DeriveKeyMechanism Mechanism { get; set; } = new DeriveKeyMechanism();
    
        /// <summary>Whether the derived key should have cryptographic operations enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        /// <summary>Description for the new key.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Optional array of key operations to be enabled for this security object. If this property is not provided, the SDKMS server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>User-defined metadata for this key. Stored as key-value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DeriveKeyRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        /// <summary>Name of the derived key. Key names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        /// <summary>Key size of the derived key in bits (not bytes).</summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Always)]
        public int Key_size { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Key_type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mechanism", Required = Newtonsoft.Json.Required.Always)]
        public DeriveKeyMechanism Mechanism { get; set; } = new DeriveKeyMechanism();
    
        /// <summary>Whether the derived key should have cryptographic operations enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        /// <summary>Description for the new key.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Optional array of key operations to be enabled for this security object. If this property is not provided, the SDKMS server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>User-defined metadata for this key. Stored as key-value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        /// <summary>If this is true, SDKMS will derive a transient key.</summary>
        [Newtonsoft.Json.JsonProperty("transient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Transient { get; set; }
    
    
    }
    
    /// <summary>Mechanism to use for key agreement.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AgreeKeyMechanism
    {
        [System.Runtime.Serialization.EnumMember(Value = @"diffie_hellman")]
        Diffie_hellman = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AgreeKeyRequest 
    {
        [Newtonsoft.Json.JsonProperty("private_key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Private_key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("public_key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Public_key { get; set; } = new SobjectDescriptor();
    
        /// <summary>Name of the agreed-upon key. Key names must be unique within an account. The name is ignored for transient keys and should be the empty string.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        /// <summary>Key size of the derived key in bits (not bytes).</summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Always)]
        public int Key_size { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Key_type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mechanism", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AgreeKeyMechanism Mechanism { get; set; }
    
        /// <summary>Whether the derived key should have cryptographic operations enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        /// <summary>Description for the new key.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Optional array of key operations to be enabled for this security object. If this property is not provided, the SDKMS server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>User-defined metadata for this key. Stored as key-value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        /// <summary>If this is true, SDKMS will derive a transient key.</summary>
        [Newtonsoft.Json.JsonProperty("transient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Transient { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class KeyObject 
    {
        /// <summary>Name of the security object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Description of the security object.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>For objects which are not elliptic curves, this is the size in bits (not bytes) of the object. This field is not returned for elliptic curves.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Key_size { get; set; }
    
        [Newtonsoft.Json.JsonProperty("elliptic_curve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EllipticCurve? Elliptic_curve { get; set; }
    
        /// <summary>Account ID of the account this security object belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Always)]
        public string Acct_id { get; set; }
    
        /// <summary>Group ID of the security group that this security object belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("creator", Required = Newtonsoft.Json.Required.Always)]
        public CreatorType Creator { get; set; } = new CreatorType();
    
        /// <summary>Key ID uniquely identifying this security object.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("obj_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Obj_type { get; set; }
    
        /// <summary>Array of key operations enabled for this security object.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>User-defined metadata for this key. Stored as key-value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        [Newtonsoft.Json.JsonProperty("origin", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectOrigin Origin { get; set; }
    
        /// <summary>This field is returned only for asymmetric keys. It contains the public key.</summary>
        [Newtonsoft.Json.JsonProperty("pub_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Pub_key { get; set; }
    
        /// <summary>This field is returned only for opaque and secret objects. It contains the contents of the object.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Value { get; set; }
    
        /// <summary>Whether this security object has cryptographic operations enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
        /// <summary>Whether this security object is compliant with cryptographic policies or not.</summary>
        [Newtonsoft.Json.JsonProperty("compliant_with_policies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Compliant_with_policies { get; set; }
    
        /// <summary>When this security object was created.</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        public string Created_at { get; set; }
    
        /// <summary>When this security object was last used.</summary>
        [Newtonsoft.Json.JsonProperty("lastused_at", Required = Newtonsoft.Json.Required.Always)]
        public string Lastused_at { get; set; }
    
        /// <summary>Transient key blob.</summary>
        [Newtonsoft.Json.JsonProperty("transient_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Transient_key { get; set; }
    
        /// <summary>True if this key's operations have never contained EXPORT.</summary>
        [Newtonsoft.Json.JsonProperty("never_exportable", Required = Newtonsoft.Json.Required.Always)]
        public bool Never_exportable { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rsa", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RsaOptions Rsa { get; set; }
    
        /// <summary>KCV for the Security Object</summary>
        [Newtonsoft.Json.JsonProperty("kcv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kcv { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyObjectState? State { get; set; }
    
        /// <summary>When a Key Undo Policy is in place, a list of (non-expired) history items is returned. Each history item represents a passed key state that can be reverted to.</summary>
        [Newtonsoft.Json.JsonProperty("history", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoryItem> History { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class HistoryItem 
    {
        /// <summary>History item ID uniquely identifying this history item</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HistoryItemState State { get; set; }
    
        /// <summary>Date and time this history item was created</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>Date and time this history item will expire. KeyObjects cannot be reverted to expired history items.</summary>
        [Newtonsoft.Json.JsonProperty("expiry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expiry { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class HistoryItemState 
    {
        /// <summary>When this KeyObject will become active</summary>
        [Newtonsoft.Json.JsonProperty("activation_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Activation_date { get; set; }
    
        [Newtonsoft.Json.JsonProperty("revocation_reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RevocationReasonCode? Revocation_reason { get; set; }
    
        /// <summary>When this security object was compromised.</summary>
        [Newtonsoft.Json.JsonProperty("compromise_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Compromise_date { get; set; }
    
        /// <summary>When this security object was deactivated</summary>
        [Newtonsoft.Json.JsonProperty("deactivation_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Deactivation_date { get; set; }
    
        /// <summary>When this security object was destroyed</summary>
        [Newtonsoft.Json.JsonProperty("destruction_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Destruction_date { get; set; }
    
        /// <summary>When the security object was deleted</summary>
        [Newtonsoft.Json.JsonProperty("deletion_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Deletion_date { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyObjectState? State { get; set; }
    
        /// <summary>Array of key operations enabled for this security object.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>Whether the key object contains only a public part</summary>
        [Newtonsoft.Json.JsonProperty("public_only", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Public_only { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rotation_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RotationPolicy Rotation_policy { get; set; }
    
    
    }
    
    /// <summary>State of the key object</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum KeyObjectState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PreActive")]
        PreActive = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Active")]
        Active = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Deactivated")]
        Deactivated = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Compromised")]
        Compromised = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Destroyed")]
        Destroyed = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Deleted")]
        Deleted = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RotationPolicy 
    {
        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RotationInterval Interval { get; set; }
    
        /// <summary>Start time of the rotation policy</summary>
        [Newtonsoft.Json.JsonProperty("effective_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Effective_at { get; set; }
    
    
    }
    
    /// <summary>Interval between key objects are rotated</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RotationInterval 
    {
        [Newtonsoft.Json.JsonProperty("interval_days", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Interval_days { get; set; }
    
        [Newtonsoft.Json.JsonProperty("interval_months", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Interval_months { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchEncryptRequest : System.Collections.ObjectModel.Collection<Anonymous>
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchDecryptRequest : System.Collections.ObjectModel.Collection<Anonymous2>
    {
    
    }
    
    /// <summary>Array of Sign requests to be performed in batch
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchSignRequest : System.Collections.ObjectModel.Collection<SignRequestEx>
    {
    
    }
    
    /// <summary>Array of Verify requests to be performed in batch
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchVerifyRequest : System.Collections.ObjectModel.Collection<VerifyRequestEx>
    {
    
    }
    
    /// <summary>Array of Mac requests to be performed in batch
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchMacRequest : System.Collections.ObjectModel.Collection<MacGenerateRequestEx>
    {
    
    }
    
    /// <summary>Array of Mac Verify requests to be performed in batch
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class BatchMacVerifyRequest : System.Collections.ObjectModel.Collection<MacVerifyRequestEx>
    {
    
    }
    
    /// <summary>Request to export security object as components</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ExportSobjectComponentsRequest 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("wrap_key_params", Required = Newtonsoft.Json.Required.Always)]
        public WrapKeyParams Wrap_key_params { get; set; } = new WrapKeyParams();
    
        /// <summary>Map from USER or App to its UUIDs</summary>
        [Newtonsoft.Json.JsonProperty("custodians", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<CreatorType> Custodians { get; set; } = new System.Collections.ObjectModel.Collection<CreatorType>();
    
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SplittingMethod Method { get; set; }
    
        /// <summary>description to the export request</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
    
    }
    
    /// <summary>Response of security object export components operation</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ExportComponentsResponse 
    {
        /// <summary>Components of the Security Object</summary>
        [Newtonsoft.Json.JsonProperty("components", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<SobjectComponent> Components { get; set; } = new System.Collections.ObjectModel.Collection<SobjectComponent>();
    
        /// <summary>KCV for the entire Security Object</summary>
        [Newtonsoft.Json.JsonProperty("key_kcv", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Key_kcv { get; set; }
    
        /// <summary>optional description to the export request</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
    
    }
    
    /// <summary>Request body to import security objcet components</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ImportSobjectComponentsRequest 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectRequest Key { get; set; } = new SobjectRequest();
    
        [Newtonsoft.Json.JsonProperty("unwrap_key_params", Required = Newtonsoft.Json.Required.Always)]
        public UnwrapKeyParams Unwrap_key_params { get; set; } = new UnwrapKeyParams();
    
        /// <summary>Map from USER or App to its UUIDs</summary>
        [Newtonsoft.Json.JsonProperty("custodians", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<CreatorType> Custodians { get; set; } = new System.Collections.ObjectModel.Collection<CreatorType>();
    
        /// <summary>An array of Security Object components</summary>
        [Newtonsoft.Json.JsonProperty("components", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<SobjectComponent> Components { get; set; } = new System.Collections.ObjectModel.Collection<SobjectComponent>();
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SplittingMethod Method { get; set; }
    
    
    }
    
    /// <summary>Security Object wrapping parameters</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WrapKeyParams 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SobjectDescriptor Key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType? Alg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CipherMode? Mode { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.</summary>
        [Newtonsoft.Json.JsonProperty("tag_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Tag_len { get; set; }
    
    
    }
    
    /// <summary>Security Object unwrapping parameters</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UnwrapKeyParams 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SobjectDescriptor Key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType? Alg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CipherMode? Mode { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.</summary>
        [Newtonsoft.Json.JsonProperty("tag_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Tag_len { get; set; }
    
    
    }
    
    /// <summary>Security Object components</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SobjectComponent 
    {
        /// <summary>component of Security Object</summary>
        [Newtonsoft.Json.JsonProperty("component", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Component { get; set; }
    
        /// <summary>component kcv value</summary>
        [Newtonsoft.Json.JsonProperty("component_kcv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Component_kcv { get; set; }
    
        [Newtonsoft.Json.JsonProperty("custodian", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreatorType Custodian { get; set; }
    
    
    }
    
    /// <summary>Key split method `XOR`</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SplittingMethod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"XOR")]
        XOR = 0,
    
    }
    
    /// <summary>A request to encrypt data using a symmetric or asymmetric key.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Alg { get; set; }
    
        /// <summary>The plaintext to encrypt.</summary>
        [Newtonsoft.Json.JsonProperty("plain", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Plain { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptMode? Mode { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.</summary>
        [Newtonsoft.Json.JsonProperty("tag_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Tag_len { get; set; }
    
    
    }
    
    /// <summary>A request to encrypt data using a symmetric or asymmetric key.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Alg { get; set; }
    
        /// <summary>The plaintext to encrypt.</summary>
        [Newtonsoft.Json.JsonProperty("plain", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Plain { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptMode? Mode { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.</summary>
        [Newtonsoft.Json.JsonProperty("tag_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Tag_len { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptResponse 
    {
        /// <summary>ID of the key used to perform encryption.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>The encrypted data.</summary>
        [Newtonsoft.Json.JsonProperty("cipher", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Cipher { get; set; }
    
        /// <summary>The initialiation value used for symmetric encryption. Not returned for asymmetric ciphers.</summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
    
    }
    
    /// <summary>alg is required. mode is required for symmetric algorithms.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptInitRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Alg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CipherMode? Mode { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
    
    }
    
    /// <summary>alg is required. mode is required for symmetric algorithms.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptInitRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Alg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CipherMode? Mode { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptInitResponse 
    {
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>The initialiation value used for symmetric encryption. Not returned for asymmetric ciphers.</summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
    
    }
    
    /// <summary>all fields are required</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptUpdateRequest 
    {
        /// <summary>Plaintext to encrypt.</summary>
        [Newtonsoft.Json.JsonProperty("plain", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Plain { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
    
    }
    
    /// <summary>all fields are required</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptUpdateRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        /// <summary>Plaintext to encrypt.</summary>
        [Newtonsoft.Json.JsonProperty("plain", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Plain { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptUpdateResponse 
    {
        /// <summary>Encrypted data.</summary>
        [Newtonsoft.Json.JsonProperty("cipher", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Cipher { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
    
    }
    
    /// <summary>all fields are required</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptFinalRequest 
    {
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.</summary>
        [Newtonsoft.Json.JsonProperty("tag_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Tag_len { get; set; }
    
    
    }
    
    /// <summary>all fields are required</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptFinalRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.</summary>
        [Newtonsoft.Json.JsonProperty("tag_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Tag_len { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class EncryptFinalResponse 
    {
        /// <summary>Encrypted data.</summary>
        [Newtonsoft.Json.JsonProperty("cipher", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Cipher { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
    
    }
    
    /// <summary>Mode and iv are required fields for symmetric key algorithms and ad and tag are required fields for GCM or CCM modes.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType? Alg { get; set; }
    
        /// <summary>The ciphertext to decrypt.</summary>
        [Newtonsoft.Json.JsonProperty("cipher", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Cipher { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptMode? Mode { get; set; }
    
        /// <summary>The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
    
    }
    
    /// <summary>Mode and iv are required fields for symmetric key algorithms and ad and tag are required fields for GCM or CCM modes.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType? Alg { get; set; }
    
        /// <summary>The ciphertext to decrypt.</summary>
        [Newtonsoft.Json.JsonProperty("cipher", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Cipher { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptMode? Mode { get; set; }
    
        /// <summary>The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptResponse 
    {
        /// <summary>The key ID of the key used to decrypt.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>The decrypted plaintext.</summary>
        [Newtonsoft.Json.JsonProperty("plain", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Plain { get; set; }
    
    
    }
    
    /// <summary>all fields are optional</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptInitRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType? Alg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CipherMode? Mode { get; set; }
    
        /// <summary>The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptInitRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType? Alg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CipherMode? Mode { get; set; }
    
        /// <summary>The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptInitResponse 
    {
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
    
    }
    
    /// <summary>all fields are required</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptUpdateRequest 
    {
        /// <summary>Ciphertext to decrypt.</summary>
        [Newtonsoft.Json.JsonProperty("cipher", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Cipher { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
    
    }
    
    /// <summary>all fields are required</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptUpdateRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        /// <summary>Ciphertext to decrypt.</summary>
        [Newtonsoft.Json.JsonProperty("cipher", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Cipher { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptUpdateResponse 
    {
        /// <summary>Decrypted plaintext.</summary>
        [Newtonsoft.Json.JsonProperty("plain", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Plain { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
    
    }
    
    /// <summary>all fields are required</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptFinalRequest 
    {
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
        /// <summary>The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
    
    }
    
    /// <summary>all fields are required</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptFinalRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        public byte[] State { get; set; }
    
        /// <summary>The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DecryptFinalResponse 
    {
        /// <summary>Decrypted plaintext.</summary>
        [Newtonsoft.Json.JsonProperty("plain", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Plain { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignRequest 
    {
        [Newtonsoft.Json.JsonProperty("hash_alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Hash_alg { get; set; }
    
        /// <summary>Hash of the data to be signed. Exactly one of `hash` and `data` is required.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Hash { get; set; }
    
        /// <summary>Data to be signed. Exactly one of `hash` and `data` is required. To reduce request size and avoid reaching the request size limit, prefer `hash`. When using Ed25519 keys, a distinction is made between providing the message directly in `data` and providing a prehashed value in `hash`. Providing a full message results in an "Ed25519" signature while providing `hash` results in an "Ed25519ph" signature, which is not compatible. See RFC 8032 for details.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Data { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SignatureMode Mode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("deterministic_signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deterministic_signature { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("hash_alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Hash_alg { get; set; }
    
        /// <summary>Hash of the data to be signed. Exactly one of `hash` and `data` is required.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Hash { get; set; }
    
        /// <summary>Data to be signed. Exactly one of `hash` and `data` is required. To reduce request size and avoid reaching the request size limit, prefer `hash`.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Data { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SignatureMode Mode { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignResponse 
    {
        /// <summary>Key ID of the key used to sign this data.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>Signature of the data's hash.</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Signature { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VerifyRequest 
    {
        [Newtonsoft.Json.JsonProperty("hash_alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Hash_alg { get; set; }
    
        /// <summary>The hash of the data on which the signature is being verified. Exactly one of `hash` and `data` is required.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Hash { get; set; }
    
        /// <summary>The data on which the signature is being verified. Exactly one of `hash` and `data` is required. To reduce request size and avoid reaching the request size limit, prefer `hash`.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Data { get; set; }
    
        /// <summary>A signature created with the private key corresponding to this public key.</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Signature { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SignatureMode Mode { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VerifyRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("hash_alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Hash_alg { get; set; }
    
        /// <summary>The hash of the data on which the signature is being verified. Exactly one of `hash` and `data` is required.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Hash { get; set; }
    
        /// <summary>The data on which the signature is being verified. Exactly one of `hash` and `data` is required. To reduce request size and avoid reaching the request size limit, prefer `hash`.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Data { get; set; }
    
        /// <summary>A signature created with the private key corresponding to this public key.</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Signature { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SignatureMode Mode { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VerifyResponse 
    {
        /// <summary>The Key ID of the key used to verify this data.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>True if the signature verified and False if it did not.</summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Always)]
        public bool Result { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DigestRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Alg { get; set; }
    
        /// <summary>Data to be hashed.</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ObjectDigestRequest 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Alg { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VerifyKcvRequest 
    {
        /// <summary>KCV to verify against provided key material in 'value'</summary>
        [Newtonsoft.Json.JsonProperty("kcv", Required = Newtonsoft.Json.Required.Always)]
        public string Kcv { get; set; }
    
        /// <summary>Key material</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        public string Value { get; set; }
    
        [Newtonsoft.Json.JsonProperty("obj_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Obj_type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VerifyKcvResponse 
    {
        /// <summary>True if the KCV successfully verified, and false if it did not.</summary>
        [Newtonsoft.Json.JsonProperty("verified", Required = Newtonsoft.Json.Required.Always)]
        public bool Verified { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DigestResponse 
    {
        /// <summary>Hash of the data.</summary>
        [Newtonsoft.Json.JsonProperty("digest", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Digest { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacGenerateRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm? Alg { get; set; }
    
        /// <summary>Data to compute the MAC of.</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacGenerateRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm? Alg { get; set; }
    
        /// <summary>Data to compute the MAC of.</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacGenerateResponse 
    {
        /// <summary>Key ID of the key used to generate the MAC.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>The MAC generated for the input data (returned for HMAC operation).</summary>
        [Newtonsoft.Json.JsonProperty("digest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Digest { get; set; }
    
        /// <summary>The MAC generated for the input data (returned for CMAC operation).</summary>
        [Newtonsoft.Json.JsonProperty("mac", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Mac { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacVerifyRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Alg { get; set; }
    
        /// <summary>The data to verify the MAC of.</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Data { get; set; }
    
        /// <summary>The MAC previously computed for the input data. NOTE - this field is deprecated. Instead you should use mac field.</summary>
        [Newtonsoft.Json.JsonProperty("digest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Digest { get; set; }
    
        /// <summary>The MAC previously computed for the input data.</summary>
        [Newtonsoft.Json.JsonProperty("mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Mac { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacVerifyRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Alg { get; set; }
    
        /// <summary>The data to verify the MAC of.</summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Data { get; set; }
    
        /// <summary>The MAC previously computed for the input data. NOTE - this field is deprecated. Instead you should use mac field.</summary>
        [Newtonsoft.Json.JsonProperty("digest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Digest { get; set; }
    
        /// <summary>The MAC previously computed for the input data.</summary>
        [Newtonsoft.Json.JsonProperty("mac", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Mac { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MacVerifyResponse 
    {
        /// <summary>Key ID of the key used to verify the MAC.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>True if the MAC successfully verified, and false if it did not.</summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Always)]
        public bool Result { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AuthResponse 
    {
        /// <summary>Number of seconds from token issuance that the token will expire.</summary>
        [Newtonsoft.Json.JsonProperty("expires_in", Required = Newtonsoft.Json.Required.Always)]
        public int Expires_in { get; set; }
    
        /// <summary>Bearer token to be used to authenticate to other APIs.</summary>
        [Newtonsoft.Json.JsonProperty("access_token", Required = Newtonsoft.Json.Required.Always)]
        public string Access_token { get; set; }
    
        /// <summary>The UUID of the entity that was authorized. For users, this will be the user's UUID. For applications, this will be the application's UUID.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("entity_id", Required = Newtonsoft.Json.Required.Always)]
        public string Entity_id { get; set; }
    
    
    }
    
    /// <summary>Type of Subscription.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SubscriptionType 
    {
    
    }
    
    /// <summary>Describes a request to update subscription.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SubscriptionChangeRequest 
    {
        [Newtonsoft.Json.JsonProperty("subscription", Required = Newtonsoft.Json.Required.Always)]
        public SubscriptionType Subscription { get; set; } = new SubscriptionType();
    
        /// <summary>contact information, e.g. phone number</summary>
        [Newtonsoft.Json.JsonProperty("contact", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Contact { get; set; }
    
        /// <summary>additional comments</summary>
        [Newtonsoft.Json.JsonProperty("comment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Comment { get; set; }
    
    
    }
    
    /// <summary>Type of notification preference.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum NotificationPref
    {
        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Email")]
        Email = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Phone")]
        Phone = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Both")]
        Both = 3,
    
    }
    
    /// <summary>State of account.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AccountState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PendingConfirmation")]
        PendingConfirmation = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Activated")]
        Activated = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Disabled")]
        Disabled = 2,
    
    }
    
    /// <summary>Type of authentication.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AuthType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Fortanix")]
        Fortanix = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FortanixMFA")]
        FortanixMFA = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"External")]
        External = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Account 
    {
        /// <summary>Name of the account. Account names must be unique within an SDKMS instance.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Account ID uniquely identifying this account.</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Always)]
        public string Acct_id { get; set; }
    
        /// <summary>Description of this account.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Organization (e.g. company name) that owns this account</summary>
        [Newtonsoft.Json.JsonProperty("organization", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Organization { get; set; }
    
        /// <summary>Main country associated with this account</summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Country { get; set; }
    
        /// <summary>Contact phone number associated with this account</summary>
        [Newtonsoft.Json.JsonProperty("phone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Phone { get; set; }
    
        [Newtonsoft.Json.JsonProperty("notification_pref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NotificationPref? Notification_pref { get; set; }
    
        [Newtonsoft.Json.JsonProperty("auth_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AuthConfig Auth_config { get; set; }
    
        [Newtonsoft.Json.JsonProperty("subscription", Required = Newtonsoft.Json.Required.Always)]
        public SubscriptionType Subscription { get; set; } = new SubscriptionType();
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccountState State { get; set; }
    
        [Newtonsoft.Json.JsonProperty("auth_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AuthType Auth_type { get; set; }
    
        /// <summary>Map from UUIDs to LoggingConfig objects</summary>
        [Newtonsoft.Json.JsonProperty("logging_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LoggingConfig> Logging_configs { get; set; }
    
        /// <summary>Whether this account is enabled. This may only be changed by sysadmins.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        /// <summary>When this account was created.</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>When this accout was upgraded a paid subscription.</summary>
        [Newtonsoft.Json.JsonProperty("initial_purchase_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Initial_purchase_at { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pending_subscription_change_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubscriptionChangeRequest Pending_subscription_change_request { get; set; }
    
        /// <summary>Sysadmin-defined metadata for this account. Stored as key-value pairs. This field is only visible to sysadmin users.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_undo_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyUndoPolicy Key_undo_policy { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AccountRequest 
    {
        /// <summary>Name of the account. Accounts must be unique within an SDKMS instance.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Account ID uniquely identifying this account.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Organization (e.g. company name) that owns this account</summary>
        [Newtonsoft.Json.JsonProperty("organization", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Organization { get; set; }
    
        /// <summary>Main country associated with this account</summary>
        [Newtonsoft.Json.JsonProperty("country", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Country { get; set; }
    
        /// <summary>Contact phone number associated with this account</summary>
        [Newtonsoft.Json.JsonProperty("phone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Phone { get; set; }
    
        [Newtonsoft.Json.JsonProperty("notification_pref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NotificationPref? Notification_pref { get; set; }
    
        [Newtonsoft.Json.JsonProperty("auth_config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AuthConfig Auth_config { get; set; }
    
        [Newtonsoft.Json.JsonProperty("add_logging_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LoggingConfigRequest> Add_logging_configs { get; set; }
    
        /// <summary>Map from UUIDs to LoggingConfigRequest objects</summary>
        [Newtonsoft.Json.JsonProperty("mod_logging_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LoggingConfigRequest> Mod_logging_configs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("del_logging_configs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Del_logging_configs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pending_subscription_change_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubscriptionChangeRequest Pending_subscription_change_request { get; set; }
    
        /// <summary>Whether this account is enabled. This may only be changed by sysadmins.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("subscription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubscriptionType Subscription { get; set; }
    
        /// <summary>Sysadmin-defined metadata for this account. Stored as key-value pairs. This field may only be used by sysadmin users.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_undo_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KeyUndoPolicy Key_undo_policy { get; set; }
    
    
    }
    
    /// <summary>A policy to revert operations done inadvertently</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class KeyUndoPolicy 
    {
        /// <summary>The time window in seconds operations can be reverted</summary>
        [Newtonsoft.Json.JsonProperty("undo_time_window", Required = Newtonsoft.Json.Required.Always)]
        public int Undo_time_window { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AuthConfig 
    {
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AuthConfigPassword Password { get; set; }
    
        /// <summary>XML metadata for a SAML 2.0 Identity Provider (IdP).</summary>
        [Newtonsoft.Json.JsonProperty("saml", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Saml { get; set; }
    
        /// <summary>Signed JWT verification data</summary>
        [Newtonsoft.Json.JsonProperty("signed_jwt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AuthConfigSignedJWT Signed_jwt { get; set; }
    
    
    }
    
    /// <summary>Configuration for password-based authentication.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AuthConfigPassword 
    {
        /// <summary>Reserved for future use, must be false.</summary>
        [Newtonsoft.Json.JsonProperty("require_2fa", Required = Newtonsoft.Json.Required.Always)]
        public bool Require_2fa { get; set; }
    
        /// <summary>Reserved for future use, must be false.</summary>
        [Newtonsoft.Json.JsonProperty("administrators_only", Required = Newtonsoft.Json.Required.Always)]
        public bool Administrators_only { get; set; }
    
    
    }
    
    /// <summary>Type of signing key.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum JWTSigningKeyType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Fetched")]
        Fetched = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Stored")]
        Stored = 1,
    
    }
    
    /// <summary>Configuration for signed JWT authentication.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AuthConfigSignedJWT 
    {
        /// <summary>An array of valid issuers. JWT presented for authentication must have one of these issuers.</summary>
        [Newtonsoft.Json.JsonProperty("valid_issuers", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Valid_issuers { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Details of signning key that will be used for signature verification.</summary>
        [Newtonsoft.Json.JsonProperty("signing_keys", Required = Newtonsoft.Json.Required.Always)]
        public Signing_keys Signing_keys { get; set; } = new Signing_keys();
    
    
    }
    
    /// <summary>Flags for users roles and state for an account.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum UserAccountFlags
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AccountAdministrator")]
        AccountAdministrator = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountMember")]
        AccountMember = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountAuditor")]
        AccountAuditor = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StateEnabled")]
        StateEnabled = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PendingInvite")]
        PendingInvite = 4,
    
    }
    
    /// <summary>Flags for users role for a group.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum UserGroupFlags
    {
        [System.Runtime.Serialization.EnumMember(Value = @"GroupAdministrator")]
        GroupAdministrator = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GroupAuditor")]
        GroupAuditor = 1,
    
    }
    
    /// <summary>State of users.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum UserState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PendingConfirmation")]
        PendingConfirmation = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Locked")]
        Locked = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Disabled")]
        Disabled = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Active")]
        Active = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class User 
    {
        /// <summary>User ID uniquely identifying this user.</summary>
        [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Always)]
        public string User_id { get; set; }
    
        /// <summary>The User's email address.</summary>
        [Newtonsoft.Json.JsonProperty("user_email", Required = Newtonsoft.Json.Required.Always)]
        public string User_email { get; set; }
    
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public UserState State { get; set; }
    
        [Newtonsoft.Json.JsonProperty("account_role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<UserAccountFlags> Account_role { get; set; }
    
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.Always)]
        public UserGroupMap Groups { get; set; } = new UserGroupMap();
    
        /// <summary>Whether this user's account is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
        /// <summary>Whether this user's email has been verified.</summary>
        [Newtonsoft.Json.JsonProperty("email_verified", Required = Newtonsoft.Json.Required.Always)]
        public bool Email_verified { get; set; }
    
        /// <summary>When this user was added to SDKMS.</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        public string Created_at { get; set; }
    
        /// <summary>When this user last logged in.</summary>
        [Newtonsoft.Json.JsonProperty("last_logged_in_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_logged_in_at { get; set; }
    
        [Newtonsoft.Json.JsonProperty("u2f_devices", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<U2fDevice> U2f_devices { get; set; } = new System.Collections.ObjectModel.Collection<U2fDevice>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UserRequest 
    {
        /// <summary>User's email address.</summary>
        [Newtonsoft.Json.JsonProperty("user_email", Required = Newtonsoft.Json.Required.Always)]
        public string User_email { get; set; }
    
        /// <summary>The password to assign to this user in SDKMS.</summary>
        [Newtonsoft.Json.JsonProperty("user_password", Required = Newtonsoft.Json.Required.Always)]
        public string User_password { get; set; }
    
        [Newtonsoft.Json.JsonProperty("account_role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<UserAccountFlags> Account_role { get; set; }
    
        /// <summary>The user will be added to the specified security groups with the specified roles.</summary>
        [Newtonsoft.Json.JsonProperty("add_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserGroupMap Add_groups { get; set; }
    
        /// <summary>The user will be removed from the specified security groups.</summary>
        [Newtonsoft.Json.JsonProperty("del_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserGroupMap Del_groups { get; set; }
    
        /// <summary>The user's role in the specified groups will be updated to the specified roles.</summary>
        [Newtonsoft.Json.JsonProperty("mod_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserGroupMap Mod_groups { get; set; }
    
        /// <summary>Whether this application is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("add_u2f_devices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<U2fAddDeviceRequest> Add_u2f_devices { get; set; }
    
        [Newtonsoft.Json.JsonProperty("del_u2f_devices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<U2fDelDeviceRequest> Del_u2f_devices { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rename_u2f_devices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<U2fRenameDeviceRequest> Rename_u2f_devices { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SignupRequest 
    {
        /// <summary>User's email address.</summary>
        [Newtonsoft.Json.JsonProperty("user_email", Required = Newtonsoft.Json.Required.Always)]
        public string User_email { get; set; }
    
        /// <summary>The password to assign to this user in SDKMS.</summary>
        [Newtonsoft.Json.JsonProperty("user_password", Required = Newtonsoft.Json.Required.Always)]
        public string User_password { get; set; }
    
        [Newtonsoft.Json.JsonProperty("first_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string First_name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("last_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("recaptcha_response", Required = Newtonsoft.Json.Required.Always)]
        public string Recaptcha_response { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PasswordChangeRequest 
    {
        [Newtonsoft.Json.JsonProperty("current_password", Required = Newtonsoft.Json.Required.Always)]
        public string Current_password { get; set; }
    
        [Newtonsoft.Json.JsonProperty("new_password", Required = Newtonsoft.Json.Required.Always)]
        public string New_password { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SelectAccountRequest 
    {
        /// <summary>Uuid format string, example - a41152ed-c26e-4c6e-a8d1-8820e36972c3</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Always)]
        public string Acct_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SelectAccountResponse 
    {
        [Newtonsoft.Json.JsonProperty("cookie", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cookie { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ProcessInviteRequest 
    {
        [Newtonsoft.Json.JsonProperty("accepts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Accepts { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rejects", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Rejects { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ForgotPasswordRequest 
    {
        [Newtonsoft.Json.JsonProperty("user_email", Required = Newtonsoft.Json.Required.Always)]
        public string User_email { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PasswordResetRequest 
    {
        [Newtonsoft.Json.JsonProperty("reset_token", Required = Newtonsoft.Json.Required.Always)]
        public string Reset_token { get; set; }
    
        [Newtonsoft.Json.JsonProperty("new_password", Required = Newtonsoft.Json.Required.Always)]
        public string New_password { get; set; }
    
    
    }
    
    /// <summary>A UserAccountMap has keys which are the UUIDs of the accounts that the user belongs to. The value for each key is an array of UserAccountFlags representing the account properties.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UserAccountMap : System.Collections.Generic.Dictionary<string, System.Collections.ObjectModel.Collection<UserAccountFlags>>
    {
    
    }
    
    /// <summary>A UserGroupMap has keys which are the UUIDs of the groups that the user belongs to. The value for each key is an array of UserGroupFlags representing the group properties.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UserGroupMap : System.Collections.Generic.Dictionary<string, System.Collections.ObjectModel.Collection<UserGroupFlags>>
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ValidateTokenRequest 
    {
        [Newtonsoft.Json.JsonProperty("reset_token", Required = Newtonsoft.Json.Required.Always)]
        public string Reset_token { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ValidateTokenResponse 
    {
        [Newtonsoft.Json.JsonProperty("user_email", Required = Newtonsoft.Json.Required.Always)]
        public string User_email { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class AuditLogResponse 
    {
        /// <summary>Type of action performed.</summary>
        [Newtonsoft.Json.JsonProperty("action_type", Required = Newtonsoft.Json.Required.Always)]
        public string Action_type { get; set; }
    
        /// <summary>Type of entity performing action.</summary>
        [Newtonsoft.Json.JsonProperty("actor_type", Required = Newtonsoft.Json.Required.Always)]
        public string Actor_type { get; set; }
    
        /// <summary>Audit log message.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        public string Message { get; set; }
    
        /// <summary>Severity of audit log message.</summary>
        [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Always)]
        public string Severity { get; set; }
    
        /// <summary>Time that action occurred.</summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Always)]
        public string Time { get; set; }
    
        /// <summary>ID of object acted upon.</summary>
        [Newtonsoft.Json.JsonProperty("object_id", Required = Newtonsoft.Json.Required.Always)]
        public string Object_id { get; set; }
    
        /// <summary>ID of entity performing action.</summary>
        [Newtonsoft.Json.JsonProperty("actor_id", Required = Newtonsoft.Json.Required.Always)]
        public string Actor_id { get; set; }
    
        /// <summary>Account ID of the account this audit log applies to.</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Always)]
        public string Acct_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("group_ids", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Group_ids { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StatsResponse 
    {
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> Time { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WrapKeyRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Alg { get; set; }
    
        /// <summary>The key ID (not name or description) of the key being wrapped.</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Always)]
        public string Kid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptMode? Mode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyFormat? Key_format { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.</summary>
        [Newtonsoft.Json.JsonProperty("tag_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Tag_len { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WrapKeyRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Subject { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Alg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptMode? Mode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("key_format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public KeyFormat? Key_format { get; set; }
    
        /// <summary>For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, SDKMS will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.</summary>
        [Newtonsoft.Json.JsonProperty("tag_len", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Tag_len { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class WrapKeyResponse 
    {
        /// <summary>The wrapped key.</summary>
        [Newtonsoft.Json.JsonProperty("wrapped_key", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Wrapped_key { get; set; }
    
        /// <summary>The initialiation value used for symmetric encryption. Not returned for asymmetric ciphers.</summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UnwrapKeyRequest 
    {
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Alg { get; set; }
    
        /// <summary>Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("obj_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Obj_type { get; set; }
    
        /// <summary>A Security Object previously wrapped with another key.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("wrapped_key", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Wrapped_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptMode? Mode { get; set; }
    
        /// <summary>The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
        /// <summary>Name of the security object to unwrap. Security object names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Description of the Security object to unwrap.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Optional array of key operations to be enabled for this security object. If this property is not provided, the SDKMS server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>User-defined metadata for this key. Stored as key-value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        /// <summary>Whether the new security object should be enabled. Disabled security objects may not perform cryptographic operations.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        /// <summary>If this is true, SDKMS will unwrap a transient key.</summary>
        [Newtonsoft.Json.JsonProperty("transient", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Transient { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rsa", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RsaOptions Rsa { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UnwrapKeyRequestEx 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        public SobjectDescriptor Key { get; set; } = new SobjectDescriptor();
    
        [Newtonsoft.Json.JsonProperty("alg", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Alg { get; set; }
    
        /// <summary>Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("group_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("obj_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ObjectType Obj_type { get; set; }
    
        /// <summary>A Security Object previously wrapped with another key.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("wrapped_key", Required = Newtonsoft.Json.Required.Always)]
        public byte[] Wrapped_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CryptMode? Mode { get; set; }
    
        /// <summary>The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("iv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Iv { get; set; }
    
        /// <summary>The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("ad", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Ad { get; set; }
    
        /// <summary>The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Tag { get; set; }
    
        /// <summary>Name of the security object to unwrap. Security object names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Description of the Security object to unwrap.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Optional array of key operations to be enabled for this security object. If this property is not provided, the SDKMS server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("key_ops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<KeyOperations> Key_ops { get; set; }
    
        /// <summary>User-defined metadata for this key. Stored as key-value pairs.</summary>
        [Newtonsoft.Json.JsonProperty("custom_metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Custom_metadata { get; set; }
    
        /// <summary>Whether the new security object should be enabled. Disabled security objects may not perform cryptographic operations.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rsa", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RsaOptions Rsa { get; set; }
    
    
    }
    
    /// <summary>Challenge for registring or authenticating with a U2F two factor device.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class MfaChallenge 
    {
        [Newtonsoft.Json.JsonProperty("u2f_challenge", Required = Newtonsoft.Json.Required.Always)]
        public string U2f_challenge { get; set; }
    
        [Newtonsoft.Json.JsonProperty("u2f_keys", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<U2fKey> U2f_keys { get; set; } = new System.Collections.ObjectModel.Collection<U2fKey>();
    
    
    }
    
    /// <summary>A U2F key that may be used for two factor authentication.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class U2fKey 
    {
        [Newtonsoft.Json.JsonProperty("keyHandle", Required = Newtonsoft.Json.Required.Always)]
        public string KeyHandle { get; set; }
    
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public string Version { get; set; }
    
    
    }
    
    /// <summary>Backup recovery codes for two factor authentication.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RecoveryCodes 
    {
        [Newtonsoft.Json.JsonProperty("recovery_codes", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Recovery_codes { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>A U2f device that may be used for second factor authentication.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class U2fDevice 
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Description of a U2F device to add for two factor authentication.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class U2fAddDeviceRequest 
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("registrationData", Required = Newtonsoft.Json.Required.Always)]
        public string RegistrationData { get; set; }
    
        [Newtonsoft.Json.JsonProperty("clientData", Required = Newtonsoft.Json.Required.Always)]
        public string ClientData { get; set; }
    
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public string Version { get; set; }
    
    
    }
    
    /// <summary>Request to delete a U2F device.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class U2fDelDeviceRequest 
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Request to rename a U2F device.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class U2fRenameDeviceRequest 
    {
        [Newtonsoft.Json.JsonProperty("old_name", Required = Newtonsoft.Json.Required.Always)]
        public string Old_name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("new_name", Required = Newtonsoft.Json.Required.Always)]
        public string New_name { get; set; }
    
    
    }
    
    /// <summary>Server mode.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ServerMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Software")]
        Software = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Sgx")]
        Sgx = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class VersionResponse 
    {
        /// <summary>The SDKMS server version. This is encoded as major.minor.build. For example, 1.0.25.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        public string Version { get; set; }
    
        /// <summary>The API version implemented by this server.</summary>
        [Newtonsoft.Json.JsonProperty("api_version", Required = Newtonsoft.Json.Required.Always)]
        public string Api_version { get; set; }
    
        [Newtonsoft.Json.JsonProperty("server_mode", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ServerMode Server_mode { get; set; }
    
        /// <summary>FIPS level at which SDKMS in running. If this field is absent, then SDKMS is not running in FIPS compliant mode.</summary>
        [Newtonsoft.Json.JsonProperty("fips_level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Fips_level { get; set; }
    
    
    }
    
    /// <summary>Type of this plugin.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PluginType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Standard")]
        Standard = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Impersonating")]
        Impersonating = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CustomAlgorithm")]
        CustomAlgorithm = 2,
    
    }
    
    /// <summary>Language for plugin code.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Language
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Lua")]
        Lua = 0,
    
    }
    
    /// <summary>Plugin code that will be executed in SDKMS.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PluginSource 
    {
        [Newtonsoft.Json.JsonProperty("language", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Language Language { get; set; }
    
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        public string Code { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Plugin 
    {
        /// <summary>Name of the plugin. Plugin names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Plugin ID uniquely identifying this plugin.</summary>
        [Newtonsoft.Json.JsonProperty("plugin_id", Required = Newtonsoft.Json.Required.Always)]
        public string Plugin_id { get; set; }
    
        /// <summary>Description of this plugin.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>The account ID of the account that this plugin belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Always)]
        public string Acct_id { get; set; }
    
        /// <summary>An array of security group IDs. The plugin belongs to each Security Group in this array.</summary>
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Groups { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>The default group of this plugin. This is the group where security objects will be created by default by this plugin.</summary>
        [Newtonsoft.Json.JsonProperty("default_group", Required = Newtonsoft.Json.Required.Always)]
        public string Default_group { get; set; }
    
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        public PluginSource Source { get; set; } = new PluginSource();
    
        /// <summary>Whether this plugin is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("plugin_type", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PluginType Plugin_type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("creator", Required = Newtonsoft.Json.Required.Always)]
        public CreatorType Creator { get; set; } = new CreatorType();
    
        /// <summary>When this plugin was created.</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        public string Created_at { get; set; }
    
        /// <summary>When this plugin was last run.</summary>
        [Newtonsoft.Json.JsonProperty("lastrun_at", Required = Newtonsoft.Json.Required.Always)]
        public string Lastrun_at { get; set; }
    
        /// <summary>When this plugin was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("lastupdated_at", Required = Newtonsoft.Json.Required.Always)]
        public string Lastupdated_at { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PluginRequest 
    {
        /// <summary>Name of the plugin. Plugin names must be unique within an account.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        public string Name { get; set; }
    
        /// <summary>Description of this plugin.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>An array of Security Group IDs to add to this plugin.</summary>
        [Newtonsoft.Json.JsonProperty("add_groups", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Add_groups { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>An array of security group IDs to remove from this plugin.</summary>
        [Newtonsoft.Json.JsonProperty("del_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Del_groups { get; set; }
    
        /// <summary>The default group of this plugin. This is the group where security objects will be created by default by this plugin.</summary>
        [Newtonsoft.Json.JsonProperty("default_group", Required = Newtonsoft.Json.Required.Always)]
        public string Default_group { get; set; }
    
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        public PluginSource Source { get; set; } = new PluginSource();
    
        /// <summary>Whether this plugin is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("plugin_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PluginType? Plugin_type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PluginInvokeRequest 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PluginInvokeResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConfirmEmailRequest 
    {
        [Newtonsoft.Json.JsonProperty("confirm_token", Required = Newtonsoft.Json.Required.Always)]
        public string Confirm_token { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConfirmEmailResponse 
    {
        [Newtonsoft.Json.JsonProperty("user_email", Required = Newtonsoft.Json.Required.Always)]
        public string User_email { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SplunkLoggingConfig 
    {
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Always)]
        public string Host { get; set; }
    
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        public int Port { get; set; }
    
        /// <summary>The Splunk index that will receive log items</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Always)]
        public string Index { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Always)]
        public TlsConfig Tls { get; set; } = new TlsConfig();
    
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SplunkLoggingConfigRequest 
    {
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }
    
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Port { get; set; }
    
        /// <summary>The Splunk index that will receive log items</summary>
        [Newtonsoft.Json.JsonProperty("index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Index { get; set; }
    
        /// <summary>The Splunk authentication token</summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Token { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TlsConfig Tls { get; set; }
    
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StackdriverLoggingConfig 
    {
        /// <summary>The log ID that will recieve the log items (see https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry).</summary>
        [Newtonsoft.Json.JsonProperty("log_id", Required = Newtonsoft.Json.Required.Always)]
        public string Log_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("service_account_key", Required = Newtonsoft.Json.Required.Always)]
        public GoogleServiceAccountKey Service_account_key { get; set; } = new GoogleServiceAccountKey();
    
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Always)]
        public bool Enabled { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class StackdriverLoggingConfigRequest 
    {
        /// <summary>The log ID that will recieve the log items (see https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry).</summary>
        [Newtonsoft.Json.JsonProperty("log_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Log_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("service_account_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GoogleServiceAccountKey Service_account_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
    
    }
    
    /// <summary>A Google service account key object. See https://cloud.google.com/video-intelligence/docs/common/auth.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class GoogleServiceAccountKey 
    {
        /// <summary>Must be "service_account"</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        public string Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Always)]
        public string Project_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("private_key_id", Required = Newtonsoft.Json.Required.Always)]
        public string Private_key_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("private_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Private_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("client_email", Required = Newtonsoft.Json.Required.Always)]
        public string Client_email { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LoggingConfig 
    {
        [Newtonsoft.Json.JsonProperty("splunk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SplunkLoggingConfig Splunk { get; set; }
    
        [Newtonsoft.Json.JsonProperty("stackdriver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StackdriverLoggingConfig Stackdriver { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LoggingConfigRequest 
    {
        [Newtonsoft.Json.JsonProperty("splunk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SplunkLoggingConfigRequest Splunk { get; set; }
    
        [Newtonsoft.Json.JsonProperty("stackdriver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StackdriverLoggingConfigRequest Stackdriver { get; set; }
    
    
    }
    
    /// <summary>TLS mod.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TlsMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"disabled")]
        Disabled = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"opportunistic")]
        Opportunistic = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"required")]
        Required = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CaConfig 
    {
        [Newtonsoft.Json.JsonProperty("ca_set", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CaConfigCa_set? Ca_set { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pinned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<byte[]> Pinned { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TlsConfig 
    {
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TlsMode Mode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("validate_hostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Validate_hostname { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ca", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CaConfig Ca { get; set; }
    
    
    }
    
    /// <summary>RSA-specific options.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RsaOptions 
    {
        /// <summary>Specify on Create only. Returned on Get. Size in bits (not bytes) of the RSA key.</summary>
        [Newtonsoft.Json.JsonProperty("key_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Key_size { get; set; }
    
        /// <summary>Specify on Create only. Public exponent to use for generating the RSA key.</summary>
        [Newtonsoft.Json.JsonProperty("public_exponent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Public_exponent { get; set; }
    
        /// <summary>Encryption policy for this RSA key. When doing an encryption or key wrapping operation, the policies are evaluated against the specified parameters one by one. If one matches, the operation is allowed. If none match, including if the policy list is empty, the operation is disallowed. Missing optional parameters will have their defaults specified according to the matched policy. The default for new keys is `[{"padding":{"OAEP":{}}]`. If (part of) a constraint is not specified, anything is allowed for that constraint. To impose no constraints, specify `[{}]`.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("encryption_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RsaEncryptionPolicy> Encryption_policy { get; set; }
    
        /// <summary>Signature policy for this RSA key. When doing a signature operation, the policies are evaluated against the specified parameters one by one. If one matches, the operation is allowed. If none match, including if the policy list is empty, the operation is disallowed. Missing optional parameters will have their defaults specified according to the matched policy. The default for new keys is `[{}]` (no constraints). If (part of) a constraint is not specified, anything is allowed for that constraint.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("signature_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RsaSignaturePolicy> Signature_policy { get; set; }
    
    
    }
    
    /// <summary>DSA-specific options.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class DsaOptions 
    {
        /// <summary>Specify on Create only. Returned on Get. Size in bits (not bytes) of the DSA subgroup. When `key_size` = 2048, allowed values are 224 or 256. When `key_size` = 3072, allowed value is 256.</summary>
        [Newtonsoft.Json.JsonProperty("subgroup_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Subgroup_size { get; set; }
    
    
    }
    
    /// <summary>Constraints on RSA encryption parameters. In general, if a constraint is not specified, anything is allowed.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RsaEncryptionPolicy 
    {
        [Newtonsoft.Json.JsonProperty("padding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Padding Padding { get; set; }
    
    
    }
    
    /// <summary>Constraints on RSA signature parameters. In general, if a constraint is not specified, anything is allowed.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RsaSignaturePolicy 
    {
        [Newtonsoft.Json.JsonProperty("padding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Padding2 Padding { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApprovalRequest 
    {
        /// <summary>UUID uniquely identifying this approval request.</summary>
        [Newtonsoft.Json.JsonProperty("request_id", Required = Newtonsoft.Json.Required.Always)]
        public string Request_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requester", Required = Newtonsoft.Json.Required.Always)]
        public Entity Requester { get; set; } = new Entity();
    
        /// <summary>When this approval request was created.</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        public string Created_at { get; set; }
    
        /// <summary>The account ID of the account that this approval request belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("acct_id", Required = Newtonsoft.Json.Required.Always)]
        public string Acct_id { get; set; }
    
        /// <summary>Operation URL path, e.g. `/crypto/v1/keys`, `/crypto/v1/groups/&lt;id&gt;`.</summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Always)]
        public string Operation { get; set; }
    
        /// <summary>Method for the operation: POST, PATCH, PUT, DELETE, or GET. Default is POST.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Always)]
        public string Method { get; set; }
    
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Always)]
        public object Body { get; set; } = new object();
    
        [Newtonsoft.Json.JsonProperty("approvers", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<Entity> Approvers { get; set; } = new System.Collections.ObjectModel.Collection<Entity>();
    
        [Newtonsoft.Json.JsonProperty("denier", Required = Newtonsoft.Json.Required.Always)]
        public Entity Denier { get; set; } = new Entity();
    
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApprovalStatus Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reviewers", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<Entity> Reviewers { get; set; } = new System.Collections.ObjectModel.Collection<Entity>();
    
        [Newtonsoft.Json.JsonProperty("subjects", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<ApprovalSubject> Subjects { get; set; } = new System.Collections.ObjectModel.Collection<ApprovalSubject>();
    
        /// <summary>Optional comment about the approval request for the reviewer.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>When this approval request expires.</summary>
        [Newtonsoft.Json.JsonProperty("expiry", Required = Newtonsoft.Json.Required.Always)]
        public string Expiry { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApprovalRequestRequest 
    {
        /// <summary>Operation URL path, e.g. `/crypto/v1/keys`, `/crypto/v1/groups/&lt;id&gt;`.</summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Always)]
        public string Operation { get; set; }
    
        /// <summary>Method for the operation: POST, PATCH, PUT, DELETE, or GET. Default is POST.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Method { get; set; }
    
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Body { get; set; }
    
        /// <summary>Optional comment about the approval request for the reviewer.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApprovableResult 
    {
        /// <summary>The HTTP status code for this partial request.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        public int Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Always)]
        public object Body { get; set; } = new object();
    
    
    }
    
    /// <summary>Approval request status.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApprovalStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PENDING")]
        PENDING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPROVED")]
        APPROVED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DENIED")]
        DENIED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 3,
    
    }
    
    /// <summary>Identifies an object acted upon by an approval request.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApprovalSubject 
    {
        /// <summary>The ID of the group being acted upon, if the subject is a group.</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }
    
        /// <summary>The ID of the security object being acted upon, if the subject is a security object.</summary>
        [Newtonsoft.Json.JsonProperty("sobject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sobject { get; set; }
    
        /// <summary>The ID of the app being acted upon, if the subject is a app.</summary>
        [Newtonsoft.Json.JsonProperty("app", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string App { get; set; }
    
        /// <summary>The ID of the plugin being acted upon, if the subject is a app.</summary>
        [Newtonsoft.Json.JsonProperty("plugin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Plugin { get; set; }
    
    
    }
    
    /// <summary>An app, user, or plugin ID.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Entity 
    {
        /// <summary>The application ID of the application that created this entity, if this entity was created by an application.</summary>
        [Newtonsoft.Json.JsonProperty("app", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string App { get; set; }
    
        /// <summary>The user ID of the user who created this entity, if this entity was created by a user.</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }
    
        /// <summary>The plugin ID of the user who created this entity, if this entity was created by a plugin.</summary>
        [Newtonsoft.Json.JsonProperty("plugin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Plugin { get; set; }
    
    
    }
    
    /// <summary>FPE-specific options. Either of type `FpeOptionsBasic` or `FpeOptionsAdvanced`, but not both.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeOptions 
    {
    
    }
    
    /// <summary>Basic FPE-specific options.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeOptionsBasic 
    {
        /// <summary>The base for input data. The radix should be a number from 2 to 36, inclusive. Each radix corresponds to a subset of ASCII alphanumeric characters (with all letters being uppercase). For instance, a radix of 10 corresponds to a character set consisting of the digits from 0 to 9, while a character set of 16 corresponds to a character set consisting of all hexadecimal digits (with letters A-F being uppercase).
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("radix", Required = Newtonsoft.Json.Required.Always)]
        public int Radix { get; set; }
    
        /// <summary>The minimum allowed length for the input data. If not specified, as a default, the min length will be set to the smallest value that allows the condition radix^min_length &gt;= 100 to be satisfied.</summary>
        [Newtonsoft.Json.JsonProperty("min_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Min_length { get; set; }
    
        /// <summary>The maximum allowed length for the input data. If not specified, a default max length of 2^16 will be used.</summary>
        [Newtonsoft.Json.JsonProperty("max_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_length { get; set; }
    
        /// <summary>The list of indices of characters to be preserved while performing encryption/decryption. Indices are Python-like, where negative indices index from the back of the token, with -1 referring to the end of the token. It is an error to specify indices greater than (min_length - 1) or less than (-min_length).
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("preserve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<int> Preserve { get; set; }
    
        /// <summary>The list of indices of characters to be masked while performing masked decryption. Indices are Python-like, where negative indices index from the back of the token, with -1 referring to the end of the token. It is an error to specify indices greater than (min_length - 1) or less than (-min_length).
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("mask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<int> Mask { get; set; }
    
        /// <summary>Whether encrypted/decrypted data should satisfy LUHN checksum formula.</summary>
        [Newtonsoft.Json.JsonProperty("luhn_check", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Luhn_check { get; set; }
    
        /// <summary>The user-friendly name for the data type that represents the input data.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Information about a complex tokenization data type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeOptionsAdvanced 
    {
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Always)]
        public FpeDataPart Format { get; set; } = new FpeDataPart();
    
        /// <summary>The user-friendly name for the data type that represents the input data.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>A duplicate of the `description` field. This field is read-only and cannot be assigned. Thus, when specifying a new `SobjectRequest`, this field should not be used.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>Structure for specifying (part of) a complex tokenization data type, which must be either an `FpeEncryptedPart`, `FpeLiteralPart`, or an `FpeCompoundPart`.
    /// <br/>
    /// <br/>***Implementation note: the current parser is locally "greedy" and does not backtrack if it happens to construct an invalid parse of an input token. The general idea here is that if a section of an input token can be parsed multiple ways, currently, the parser will "greedily" pick the first choice that matches, and, if that choice turns out to be problematic, will not go back and consider other choices. (Exactly what the "first choice" is depends on the type of the `FpeDataPart`; this is described in further detail in the descriptions of the three `FpeDataPart` variants.)***
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeDataPart 
    {
    
    }
    
    /// <summary>Structure of a simple tokenized portion of a complex tokenization data type.
    /// <br/>
    /// <br/>***Implementation note: the parser will try to (locally) match as many characters as possible. (See the description of `FpeDataPart` for more information about why this matters.)***
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeEncryptedPart 
    {
        /// <summary>The minimum allowed length for this part (in chars).</summary>
        [Newtonsoft.Json.JsonProperty("min_length", Required = Newtonsoft.Json.Required.Always)]
        public int Min_length { get; set; }
    
        /// <summary>The maximum allowed length for this part (in chars).</summary>
        [Newtonsoft.Json.JsonProperty("max_length", Required = Newtonsoft.Json.Required.Always)]
        public int Max_length { get; set; }
    
        /// <summary>The character set to use for this part.
        /// <br/>
        /// <br/>Characters should be specified as a list of pairs, where each pair [a, b] (example: ['0', '9']) represents the range of Unicode codepoints from a to b, with both bounds being inclusive. A single character can be represented as [c, c] (example: ['/', '/']).
        /// <br/>
        /// <br/>Ranges should not overlap with each other, and should not contain surrogate codepoints.
        /// <br/>
        /// <br/>*Implementation note: normally, each character is assigned a numeric value for FF1, going in the order specified in the array. For instance, in the character set [['a', 'z'], ['0', '9']], the digits from 0 to 9 DO NOT have their usual numeric values; instead, they correspond to the numerals from 26 to 35 (since they come after the 'a' to 'z' range). Note that for practical purposes, this is largely irrelevant, except when specifying a "numeric" character set, which MUST contain exactly the digits from 0 to 9, in order. **(When trying to use numeric constraints, it is best to use [["0", "9"]] as the character set.)***
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("char_set", Required = Newtonsoft.Json.Required.Always)]
        public Collection<Collection<string>> Char_set { get; set; } = new System.Collections.ObjectModel.Collection<System.Collections.ObjectModel.Collection<string>>();
    
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeConstraints Constraints { get; set; }
    
        /// <summary>The characters to be preserved while encrypting or decrypting. This should either be the string "all", or it should be an array of Python-like indices (i.e., where negative indices index from the back of the token portion, with -1 referring to the end of the array). When specifying indices, it is an error to specify indices greater than (min_length - 1) or less than (-min_length).
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("preserve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Preserve { get; set; }
    
        /// <summary>The characters to be masked while performing masked decryption. This should either be the string "all", or it should be an array of Python-like indices (i.e., where negative indices index from the back of the token portion, with -1 referring to the end of the array). When specifying indices, it is an error to specify indices greater than (min_length - 1) or less than (-min_length).
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("mask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Mask { get; set; }
    
    
    }
    
    /// <summary>A literal section of a complex tokenization data type, such as a delimiter.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeLiteralPart 
    {
        /// <summary>The list of possible strings that make up this literal portion of the token.
        /// <br/>
        /// <br/>***Implementation note: the order of the strings matters, as the parser will pick the first string that matches. (See the description of `FpeDataPart` for more information about why this matters.)***
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("literal", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Literal { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
    
    }
    
    /// <summary>Structure of a compound portion of a complex tokenization data type, itself composed of smaller parts. Note that there are three variants here:
    /// <br/> - Or -- representing an OR of multiple structures
    /// <br/> - Concat -- representing a concatenation of multiple structures
    /// <br/> - Multiple -- representing a part possibly repeated multiple times, where the part to be repeated is under the `multiple` field
    /// <br/>
    /// <br/>These three variants correspond to the `or`, `concat`, and `multiple` fields, respectively; one of these fields must be specified. It is an error to try to specify more than one variant (e.g., having both an `or` and a `concat` field).
    /// <br/>
    /// <br/>***Implementation note: for Or variants, the parser will go in the order of the choices (see description of the `or` field below), and for Multiple variants, the parser will try to (locally) match as many repetitions as possible. (See the description of `FpeDataPart` for more information about why this matters.)***
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeCompoundPart 
    {
        /// <summary>Represents an OR of multiple structures. This cannot be specified alongside the `concat` or `multiple` fields.
        /// <br/>
        /// <br/>***Implementation note: the order of the choices matters, as the parser will pick the first structure that matches. (The parser is locally "greedy"; see the description of `FpeDataPart` for more information about why this matters.)***
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("or", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FpeDataPart> Or { get; set; }
    
        /// <summary>Represents a concatentation of multiple structures (in a particular order). This cannot be specified alongside the `or` or `multiple` fields.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("concat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FpeDataPart> Concat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("multiple", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeDataPart Multiple { get; set; }
    
        /// <summary>The minimum number of times the subpart can be repeated. This field should only be used if the `multiple` field is being used.</summary>
        [Newtonsoft.Json.JsonProperty("min_repetitions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Min_repetitions { get; set; }
    
        /// <summary>The maximum number of times the subpart can be repeated. This field should only be used if the `multiple` field is being used.</summary>
        [Newtonsoft.Json.JsonProperty("max_repetitions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_repetitions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("constraints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeConstraints Constraints { get; set; }
    
        /// <summary>Whether the entire part should be preserved as-is (i.e., not tokenized). If this is set, any descendant subparts cannot contain any preserve-related fields set.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("preserve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Preserve { get; set; }
    
        /// <summary>Whether the entire part should be masked when doing masked decryption. If this is set, any descendant subparts cannot contain any mask-related fields set.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("mask", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Mask { get; set; }
    
        /// <summary>The minimum allowed length for this part (in chars).</summary>
        [Newtonsoft.Json.JsonProperty("min_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Min_length { get; set; }
    
        /// <summary>The minimum allowed length for this part (in chars).</summary>
        [Newtonsoft.Json.JsonProperty("max_length", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Max_length { get; set; }
    
    
    }
    
    /// <summary>Constraints on a portion of a complex tokenization data type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeConstraints 
    {
        /// <summary>Whether the token should satisfy the Luhn checksum. It is an error to apply this constraint to non-numeric parts, or for an encrypted part to be under more than one Luhn check constraint. Also, if an encrypted part has a Luhn check constraint applied to it and may contain at least one digit that is not preserved, it must not specify any other constraints.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("luhn_check", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Luhn_check { get; set; }
    
        /// <summary>Number that the token part should be greater than. This constraint can only be specified on (non-compound) numeric encrypted parts that are guaranteed to preserve either everything or nothing at all.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("num_gt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Num_gt { get; set; }
    
        /// <summary>Number that the token part should be smaller than. This constraint can only be specified on (non-compound) numeric encrypted parts that are guaranteed to preserve either everything or nothing at all.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("num_lt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Num_lt { get; set; }
    
        /// <summary>Numbers that the token part should not be equal to. It is an error to apply this constraint to non-numeric parts.</summary>
        [Newtonsoft.Json.JsonProperty("num_ne", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Num_ne { get; set; }
    
        /// <summary>Specifies that this portion is supposed to represent a date, or part of one. If used, no other constraints can be specified on this part. This field should either be an `FpeDate` object or an `FpeDatePart` value.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Date { get; set; }
    
        /// <summary>The subparts to apply the constraints to. If not specified, the constraints will be applied to all subparts (recursively). (This can also be explictly indicated by specifying the string "all"). If only certain subparts are to be specified, then they should be specified as an `FpeConstraintsApplicabilitySubparts` object.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("applies_to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Applies_to { get; set; }
    
    
    }
    
    /// <summary>An object representing the individual subparts that the constraints should apply to. This is an object where for each key-value pair, the key represents the (zero-based) "index" of the subpart, and the value is either "all" or another `FpeConstraintsApplicabilitySubparts` instance. Note that a Multiple part only allows for one possible key-value pair, due to it containing only one subpart.
    /// <br/>
    /// <br/>This cannot be used with OR parts; instead, specify constraints individually on each relevant subpart.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeConstraintsApplicabilitySubparts 
    {
    
    }
    
    /// <summary>Possible date-related constraint types that do not form a complete date (by themselves) for a complex tokenization data type. The part should be a numeric encrypted part that is guaranteed to either preserve all of its digits or preserve none of them, and cannot be involved in any Luhn-check constraints.
    /// <br/>
    /// <br/>Day and Month parts must have their `min_length` fields be at least 1 and their `max_length` field be exactly 2. Additionally, any leading zeros should be removed (unless required due to length restrictions). Year parts must be two to five digits long.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FpeDatePart
    {
        [System.Runtime.Serialization.EnumMember(Value = @"month")]
        Month = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"day")]
        Day = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"year")]
        Year = 2,
    
    }
    
    /// <summary>A structure for indicating that a token part represents a date. The part should be a concatenation that contains either
    /// <br/> - a Day part and a Month part
    /// <br/> - a Month part and a Year part
    /// <br/> - a Day part, a Month part, and a Year part
    /// <br/>
    /// <br/>(with this constraint applying to those subparts). These three choices correspond to the fields allowed on this object; using the wrong field, or multiple fields, is an error. The individual Month, Day, and/or Year parts that comprise the date cannot appear under Or or the Multiple compound part descendants of the overall Date part (i.e., when applying the date constraint, the "paths" from the Date part to the Month, Day, and/or Year parts can only "go through" concatenations, and not "through" Or or Multiple parts). Those parts must also be free of any preserved digits, with the exception that the overall date can be preserved, which must be done via setting the `preserve` field on the overall date part itself or one of its ancestor parts (but not on the constituent parts of the date).
    /// <br/>
    /// <br/>It is an error to "share" Day, Month, or Year parts across multiple dates.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeDate 
    {
        [Newtonsoft.Json.JsonProperty("dmy_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeDateWithBounds Dmy_date { get; set; }
    
        [Newtonsoft.Json.JsonProperty("month_day_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeDateWithBounds Month_day_date { get; set; }
    
        [Newtonsoft.Json.JsonProperty("month_year_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeDateWithBounds Month_year_date { get; set; }
    
    
    }
    
    /// <summary>A structure for specifying a date constraint, optionally bounded above (the `before` field) and/or below (the `after` field). All bounds are exclusive.
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeDateWithBounds 
    {
        [Newtonsoft.Json.JsonProperty("before", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeDateBound Before { get; set; }
    
        [Newtonsoft.Json.JsonProperty("after", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FpeDateBound After { get; set; }
    
    
    }
    
    /// <summary>A structure for specifying a particular date, used as an upper or lower bound for date parts. Note that depending on the `FpeDate` variant used, the `day` or `year` fields may be ignored. (For example, a Day-Month date would not require a `year` field, so specifying a year in a Day-Month date's upper bound is meaningless.)
    /// <br/></summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FpeDateBound 
    {
        /// <summary>The year, which should be a number less than 100000. Zero is treated as a leap year.</summary>
        [Newtonsoft.Json.JsonProperty("year", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Year { get; set; }
    
        /// <summary>The month, which should be a number from 1 to 12.</summary>
        [Newtonsoft.Json.JsonProperty("month", Required = Newtonsoft.Json.Required.Always)]
        public int Month { get; set; }
    
        /// <summary>The day, which should be a number from 1 to 31, and must not be out-of-range for the given month. February is considered to be 29 days long, unless the year, if specified, is not a leap year.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("day", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Day { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildAccountUser 
    {
        /// <summary>User ID uniquely identifying this user.</summary>
        [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Always)]
        public string User_id { get; set; }
    
        /// <summary>The User's email address.</summary>
        [Newtonsoft.Json.JsonProperty("user_email", Required = Newtonsoft.Json.Required.Always)]
        public string User_email { get; set; }
    
        [Newtonsoft.Json.JsonProperty("account_role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<UserAccountFlags> Account_role { get; set; }
    
        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.Always)]
        public UserGroupMap Groups { get; set; } = new UserGroupMap();
    
        /// <summary>When this user was added to account.</summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created_at { get; set; }
    
        /// <summary>When this user last logged in.</summary>
        [Newtonsoft.Json.JsonProperty("last_logged_in_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_logged_in_at { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ChildAccountUserRequest 
    {
        /// <summary>Account id of child account</summary>
        [Newtonsoft.Json.JsonProperty("child_acct_id", Required = Newtonsoft.Json.Required.Always)]
        public string Child_acct_id { get; set; }
    
        /// <summary>User's email address.</summary>
        [Newtonsoft.Json.JsonProperty("user_email", Required = Newtonsoft.Json.Required.Always)]
        public string User_email { get; set; }
    
        [Newtonsoft.Json.JsonProperty("account_role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<UserAccountFlags> Account_role { get; set; }
    
        /// <summary>The user will be added to the specified security groups with the specified roles.</summary>
        [Newtonsoft.Json.JsonProperty("add_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserGroupMap Add_groups { get; set; }
    
        /// <summary>The user will be removed from the specified security groups.</summary>
        [Newtonsoft.Json.JsonProperty("del_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserGroupMap Del_groups { get; set; }
    
        /// <summary>The user's role in the specified groups will be updated to the specified roles.</summary>
        [Newtonsoft.Json.JsonProperty("mod_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public UserGroupMap Mod_groups { get; set; }
    
        /// <summary>Whether this application is enabled.</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ApproveRequest 
    {
        [Newtonsoft.Json.JsonProperty("additionalProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object AdditionalProperties { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class KeyCheckValueResponse 
    {
        /// <summary>kid of a Security Object</summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kid { get; set; }
    
        /// <summary>KVC of a Security Object</summary>
        [Newtonsoft.Json.JsonProperty("kcv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Kcv { get; set; }
    
    
    }
    
    /// <summary>Configuration for an external key store</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class HmgConfig 
    {
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HmgKind Kind { get; set; }
    
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        public string Url { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Always)]
        public TlsConfig Tls { get; set; } = new TlsConfig();
    
        [Newtonsoft.Json.JsonProperty("pin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pin { get; set; }
    
        [Newtonsoft.Json.JsonProperty("slot", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Slot { get; set; }
    
        [Newtonsoft.Json.JsonProperty("access_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Access_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secret_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Secret_key { get; set; }
    
    
    }
    
    /// <summary>The kind of external key store</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum HmgKind
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AWSKMS")]
        AWSKMS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AWSCLOUDHSM")]
        AWSCLOUDHSM = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NCIPHER")]
        NCIPHER = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SAFENET")]
        SAFENET = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FORTANIX")]
        FORTANIX = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FORTANIXFIPSCLUSTER")]
        FORTANIXFIPSCLUSTER = 5,
    
    }
    
    /// <summary>Request to schedule deletion for an AWS KMS key</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ScheduleDeletionRequest 
    {
        [Newtonsoft.Json.JsonProperty("pending_window_in_days", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Pending_window_in_days { get; set; }
    
    
    }
    
    /// <summary>The encoding the value of an opaque object or certificate</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum View
    {
        [System.Runtime.Serialization.EnumMember(Value = @"json")]
        Json = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"value")]
        Value = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Anonymous 
    {
        /// <summary>Key ID (not name or description) of the key to use to encrypt request.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Always)]
        public string Kid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("request", Required = Newtonsoft.Json.Required.Always)]
        public EncryptRequest Request { get; set; } = new EncryptRequest();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Anonymous2 
    {
        /// <summary>Key ID (not name or description) of the key to use to decrypt request.
        /// <br/></summary>
        [Newtonsoft.Json.JsonProperty("kid", Required = Newtonsoft.Json.Required.Always)]
        public string Kid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("request", Required = Newtonsoft.Json.Required.Always)]
        public DecryptRequest Request { get; set; } = new DecryptRequest();
    
    
    }
    
    /// <summary>Event action type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Action_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Apps")]
        Apps = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Users")]
        Users = 1,
    
    }
    
    /// <summary>Event actor type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Actor_type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Administrative")]
        Administrative = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Auth")]
        Auth = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CryptoOperation")]
        CryptoOperation = 2,
    
    }
    
    /// <summary>Event severity type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Severity
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Info")]
        Info = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Warning")]
        Warning = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Error")]
        Error = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Critical")]
        Critical = 3,
    
    }
    
    /// <summary>Only retrieve approval requests with the specified approval status</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PENDING")]
        PENDING = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"APPROVED")]
        APPROVED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DENIED")]
        DENIED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Anonymous3 
    {
        /// <summary>The HTTP status code for this partial request.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        public int Status { get; set; }
    
        /// <summary>When the status property indicates an error, this contains the error message.</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EncryptResponse Body { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Anonymous4 
    {
        /// <summary>The HTTP status code for this partial request.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        public int Status { get; set; }
    
        /// <summary>When the status property indicates an error, this contains the error message.</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DecryptResponse Body { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Anonymous5 
    {
        /// <summary>The HTTP status code for this partial request.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        public int Status { get; set; }
    
        /// <summary>When the status property indicates an error, this contains the error message.</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SignResponse Body { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Anonymous6 
    {
        /// <summary>The HTTP status code for this partial request.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        public int Status { get; set; }
    
        /// <summary>When the status property indicates an error, this contains the error message.</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VerifyResponse Body { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Anonymous7 
    {
        /// <summary>The HTTP status code for this partial request.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        public int Status { get; set; }
    
        /// <summary>When the status property indicates an error, this contains the error message.</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MacGenerateResponse Body { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Mgf1 
    {
        [Newtonsoft.Json.JsonProperty("hash", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DigestAlgorithm Hash { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OAEP 
    {
        [Newtonsoft.Json.JsonProperty("mgf", Required = Newtonsoft.Json.Required.Always)]
        public Mgf Mgf { get; set; } = new Mgf();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PSS 
    {
        [Newtonsoft.Json.JsonProperty("mgf", Required = Newtonsoft.Json.Required.Always)]
        public Mgf Mgf { get; set; } = new Mgf();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PSS2 
    {
        [Newtonsoft.Json.JsonProperty("mgf", Required = Newtonsoft.Json.Required.Always)]
        public Mgf Mgf { get; set; } = new Mgf();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Trustedca 
    {
        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Subject { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ca_certificate", Required = Newtonsoft.Json.Required.Always)]
        public string Ca_certificate { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Signedjwt 
    {
        /// <summary>An array of valid issuers. JWT presented for authentication must have one of these issuers.</summary>
        [Newtonsoft.Json.JsonProperty("valid_issuers", Required = Newtonsoft.Json.Required.Always)]
        public System.Collections.Generic.ICollection<string> Valid_issuers { get; set; } = new System.Collections.ObjectModel.Collection<string>();
    
        /// <summary>Details of signning key that will be used for signature verification.</summary>
        [Newtonsoft.Json.JsonProperty("signing_keys", Required = Newtonsoft.Json.Required.Always)]
        public Signing_keys2 Signing_keys { get; set; } = new Signing_keys2();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Signing_keys 
    {
        /// <summary>Type of signing key, fetched or stored</summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public JWTSigningKeyType Kind { get; set; }
    
        /// <summary>In case of "stored" kind, a map of key ids (arbitrary strings) to base64-encoded DER keys</summary>
        [Newtonsoft.Json.JsonProperty("keys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Keys { get; set; }
    
        /// <summary>In case of "fetched" kind, URL for fetching public key for verification of JWT signature</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }
    
        /// <summary>In case of "fetched" kind, duration for which the public key can be cached</summary>
        [Newtonsoft.Json.JsonProperty("cache_duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Cache_duration { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CaConfigCa_set
    {
        [System.Runtime.Serialization.EnumMember(Value = @"global_roots")]
        Global_roots = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Padding 
    {
        [Newtonsoft.Json.JsonProperty("PKCS1_V15", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object PKCS1_V15 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("OAEP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OAEP2 OAEP { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Padding2 
    {
        [Newtonsoft.Json.JsonProperty("PKCS1_V15", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object PKCS1_V15 { get; set; }
    
        [Newtonsoft.Json.JsonProperty("PSS", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PSS3 PSS { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Signing_keys2 
    {
        /// <summary>Type of signing key, fetched or stored</summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Always)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public JWTSigningKeyType Kind { get; set; }
    
        /// <summary>In case of "stored" kind, a map of key ids (arbitrary strings) to base64-encoded DER keys</summary>
        [Newtonsoft.Json.JsonProperty("keys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Keys { get; set; }
    
        /// <summary>In case of "fetched" kind, URL for fetching public key for verification of JWT signature</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }
    
        /// <summary>In case of "fetched" kind, duration for which the public key can be cached</summary>
        [Newtonsoft.Json.JsonProperty("cache_duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Cache_duration { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OAEP2 
    {
        [Newtonsoft.Json.JsonProperty("mgf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Mgf Mgf { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.5.2.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PSS3 
    {
        [Newtonsoft.Json.JsonProperty("mgf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Mgf Mgf { get; set; }
    
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
#pragma warning restore 3016